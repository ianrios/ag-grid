{"version":3,"sources":["reactUi/useEffectOnce.tsx"],"names":[],"mappings":";AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAEpD;;GAEG;AACH,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,MAAiC,EAAE,EAAE;IAE/D,MAAM,QAAQ,GAAG,MAAM,CAA4B,MAAM,CAAC,CAAC;IAC3D,MAAM,SAAS,GAAG,MAAM,EAAuB,CAAC;IAChD,MAAM,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAC/B,MAAM,CAAC,EAAE,MAAM,CAAC,GAAG,QAAQ,CAAS,CAAC,CAAC,CAAC;IAEvC,IAAI,YAAY,CAAC,OAAO,EAAE;QACxB,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;KACzB;IAED,SAAS,CAAC,GAAG,EAAE;QACb,4CAA4C;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YACzB,SAAS,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;YACvC,YAAY,CAAC,OAAO,GAAG,IAAI,CAAC;SAC7B;QAED,iDAAiD;QACjD,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAEzB,OAAO,GAAG,EAAE;YACV,4DAA4D;YAC5D,qCAAqC;YACrC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;gBAAE,OAAO;aAAE;YAElC,kEAAkE;YAClE,IAAI,SAAS,CAAC,OAAO,EAAE;gBAAE,SAAS,CAAC,OAAO,EAAE,CAAC;aAAE;QACjD,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CAAC","file":"useEffectOnce.mjs","sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\n/** This should only be used a last resort for working around StrictMode!\n * Currently only used for Popup Editor due to our approach of showing a popup.\n */\nexport const useEffectOnce = (effect: () => void | (() => void)) => {\n\n    const effectFn = useRef<() => void | (() => void)>(effect);\n    const destroyFn = useRef<void | (() => void)>();\n    const effectCalled = useRef(false);\n    const rendered = useRef(false);\n    const [, setVal] = useState<number>(0);\n  \n    if (effectCalled.current) {\n      rendered.current = true;\n    }\n  \n    useEffect(() => {\n      // only execute the effect first time around\n      if (!effectCalled.current) {\n        destroyFn.current = effectFn.current();\n        effectCalled.current = true;\n      }\n\n      // this forces one render after the effect is run\n      setVal((val) => val + 1);\n\n      return () => {\n        // if the comp didn't render since the useEffect was called,\n        // we know it's the dummy React cycle\n        if (!rendered.current) { return; }\n\n        // otherwise this is not a dummy destroy, so call the destroy func\n        if (destroyFn.current) { destroyFn.current(); }\n      };\n    }, []);\n  };"]}